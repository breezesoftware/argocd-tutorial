### Kubernetes (K8S)
Kubernetes is a "container orchestration platform". It essentially abstracts the difficulty of running and scheduling a lot of individual pieces of code that depend on each other, across an arbitrary number of computers.

### Cluster
This is the highest level abstraction in K8S. It encapsulates everything below. It can contain a single computer, or hundreds or thousands.

Kubernetes is "idempotent", which means there is a constant source of truth for the cluster, and the K8S controller (the piece of code that could be called the "brain" of K8S) is constantly reconciling this desired state with the actual state of the cluster and making changes accordingly.

### Namespace
A namespace is like a virtual walled garden within a cluster. Typically a single application will have its own namespace to live in, and there are various security checks in place to make sure one namespace doesn't mess with another.

### Containers
There are a million other places on the Internet that explain containers thoroughly. But here's the short version:
Containers are tiny predefined virtual machines, that execute code. They're ephemeral. Some examples are a Node application that serves an API, a user-facing web app, or a script that processes image data.

### Pod
A pod is to a container as a molecule is to an atom. Pods encapsulate containers into a shared network and storage, and are usually ephemeral. Pods often have only one container inside them, but may have more than one. They can also have containers designated as *sidecars*, which are utility containers that get loaded *before* the main containers.

If pods often only have one container in them, why bother? Pods are an abstraction the K8S uses to make networking easier. The answer to this question will become more clear when we talk about *Deployments*.

Typically, Pods are not defined manually by the user. Pods are auto-generated by things like Deployments.

### Node
A node is an entity that appears to be a computer in K8S eyes, in which it can schedule pods. It can be a real, physical computer, or a virtual one. Nodes (almost always) contain pods. Nodes can contain pods from any number of different namespaces. By default, K8S handles which node to put which pods on, but this can be configured.

### Resource
A K8S resource is a pretty broad term to describe anything in the cluster that K8S has knowledge about. We're going to define a few below.

### Deployments
A Deployment defines a set of pods that are always to be configured a certain way. To reference the molecule analogy again, if pods are molecules, Deployments are chemical formulas for producing those molecules - they tell K8S what we want. Pods are ephemeral while Deployments are relatively constant. An example is a Deployment that asks for 3 instances of the same container. Let's say the container is a critical API, but it has a bug that's undetected - if a user accesses an obscure endpoint, the entire server will crash. 

So we define our Deployment and give it to K8S. K8S will spin up 3 pods that all have the same code running on it. If a user requests the endpoint that crashes the server, only one of those 3 pods will stop running, and the other 2 will handle all the traffic. If you notice that this one pod is down, you can simply delete the broken pod and K8S will automatically detect that it's missing and spin up a new one.

### Services
Services allow you to give a Deployment an in-cluster network name. If you create a Service and point it at a Deployment, you can access that Deployment elsewhere in the cluster (say, another Deployment) by its service name. For example, if you create a service called "my-service" on port 1234 and point it to "my-deployment", and you have an application that makes a request to "my-service:1234", the traffic will be sent to "my-deployment" automatically.

### YAML (Yet Another Markup Language)
YAML is the language used for defining K8S resources. It has a lot of dashes that look like bullet points, and a lot of people don't like it very much. However, it's pretty easy to learn.

### Ingresses
Ingresses help you route traffic from the outside world to your cluster. (A long, long time ago, to route traffic to different bits of code on a web server, you could use Nginx, which required big scary configuration files and reading lots of documentation. Now with K8S, you can configure Nginx with big scary YAML files instead). 

Joking aside, if you install some extra tools into your cluster (like ingress-nginx), Ingresses let you define a relationship like "send all traffic from https://mydomain.com to the Service my-service on port 3000" in a few lines of YAML.

### Custom Resource Definition (CRD)
CRDs are pretty much exactly what they sound like. Pods, Deployments, Services and Ingresses are all examples of K8S resources that are defined out-of-the-box - there are many others that are included too. However, K8S has a way to learn about additional resources that it doesn't know about by default, and this way is through a CRD. There are thousands, if not hundreds of thousands, of CRDs available that 3rd parties have developed for making K8S easier or more useful.

### Configuration Management
Above I state that K8S is idempotent -- there is a single source of truth for the K8S cluster. This single source of truth can be defined in YAML, and this YAML can be saved and managed elsewhere. There are a myriad of tools for managing it. The most common pattern is to manage your cluster configuration in Git, which is a central tenet of the GitOps concept. 

### Manifest
A manifest is a YAML file that defines a K8S resource. 

### Spec
This is the part of YAML where you *spec*ify the details of your K8S resource.

### Metadata
This is the part of YAML where you identify attributes of your K8S resource. You can add *annotations*, which are usually used by other applications in the cluster to perform special behavior, and *labels* which are often used to make finding and grouping resources easier. You also specify the resource's *name* and *namespace* here. 

### Helm
Helm is one way to do configuration management. Helm bundles apps together using a concept they call "charts", and are really easy to install with one command (something like `helm install someapp`). If you've ever used Homebrew on a Mac, Helm is kind of like Homebrew but for K8S. The problem with helm is that while it's really easy to install something out of the box, it's harder to configure something bespoke.

### Kustomize
Kustomize is yet another way to do config management. Kustomize comes bundled with kubectl by default, and while it's easier than Helm to customize (hence the name), it's harder to do complex templating.
